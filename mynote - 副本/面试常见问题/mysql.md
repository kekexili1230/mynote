# mysql面试常见问题

## myISAM和InnoDB存储引擎的区别

- 事务支持：

    - MyISAM：不支持事务。MyISAM表没有事务的概念，因此不具备ACID属性。
    
    - InnoDB：支持事务。InnoDB提供了事务支持，可以确保在一系列操作中要么全部成功要么全部失败，满足ACID属性。

- 锁定级别：

    - MyISAM：使用表级锁定。在读写操作时，整个表会被锁定，可能导致并发性能问题。

    - InnoDB：使用行级锁定。它能够更细粒度地控制锁定，提高并发性能，允许多个事务同时操作同一表的不同行。

- 外键支持：

    - MyISAM：不支持外键约束。无法定义外键关系，需要在应用层面进行维护数据完整性。

    - InnoDB：支持外键约束。可以定义外键关系，确保数据完整性，支持级联操作等。

- 全文本搜索：

    - MyISAM：提供全文本搜索的功能。

    - InnoDB：虽然从MySQL 5.6版本开始也支持全文本搜索，但MyISAM在这方面的性能仍然可能更好。


## 主键、唯一索引、聚簇索引、二级索引

### 主键和唯一索引

- 唯一性：

    - 主键索引： 主键索引是一种特殊的唯一索引，一个表只有一个主键索引
    
    - 唯一索引： 唯一索引要求索引列的值在整个表中是唯一的，但允许包含一个 NULL 值。一个表可以有多个唯一索引。

- NULL 值：

    - 主键索引： 主键索引不允许包含 NULL 值，每个行都必须有一个唯一的主键值。

    - 唯一索引： 唯一索引允许包含一个 NULL 值。如果唯一索引列是可为 NULL 的，那么在索引中可以有多个 NULL 值

- 索引类型：

    - 主键索引： 主键索引通常也是聚簇索引（Clustered Index），这意味着表中的数据行按照主键的顺序物理存储。

    - 唯一索引： 唯一索引可以是聚簇索引，也可以是非聚簇索引（Non-Clustered Index），具体取决于数据库引擎的实现和配置。

### 聚簇索引

- 聚簇索引不是一种具体的索引类型，而是数据存储方式

- 为什么说索引即数据，数据即索引？

    - 聚簇索引的物理存储顺序： 在使用聚簇索引的表中，数据行的物理存储顺序与聚簇索引的顺序一致。这使得相邻的数据行在磁盘上也是相邻存储的，而不是散落在不同位置。这样的存储方式对于范围查询非常有利，因为相关的数据在物理上是紧邻的。

    - 聚簇索引叶子节点存储数据行： 聚簇索引的叶子节点包含了整个数据行的信息，而不仅仅是索引键值。这使得在进行查询时，不需要回表到数据页去查找完整的数据，从而减少了 I/O 操作，提高了查询性能。

### 联合索引

联合索引（Composite Index）是一种包含多个列的索引。

### 覆盖索引

覆盖索引（Covering Index）是指一个索引包含了查询所需的所有列，而不仅仅是用于检索数据的列。通过使用覆盖索引，数据库引擎可以直接从索引中获取所有查询所需的数据，而无需回表访问实际的数据行。这可以带来显著的性能优势，因为减少了对数据表的实际访问，降低了 I/O 操作的开销。

### mysql如果确定聚簇索引列？

- 使用主键

- 如果没有主键，选择非空的唯一索引

- InnoDB隐式定义一个主键作为聚簇索引

### 二级索引

在 MySQL 中，二级索引（Secondary Index）是相对于聚簇索引（Clustered Index）之外的一种额外的索引，用于加速对表中数据的检索。它不决定数据的物理存储顺序，而是提供了对数据行的快速定位。

- 二级索引是除了主键索引（如果有定义）之外的任何其他索引

- 二级索引叶子节点存储的是主键值，通过回表操作定位数据

### 索引的代价

- 每建立一个索引生成B+树，消耗存储空间

- 每当对数据进行增、删、改操作时，都需要修改B+树，消耗性能

- 执行查询操作时，根据不同索引的查询时间成本生成查询计划，索引过多会增大分析成本，影响性能。

### 索引使用的场景 

- 全值匹配：查询条件和联合索引列完全一致

- 匹配最左边的列：查询条件只含有联合索引最左边的列

- 匹配列前缀：字符串

- 匹配范围值

- 用于排序

- 用于分组

### 回表的代价

- 在二级索引中查询读取主键值，是顺序读取

- 回表时，根据主键索引读取数据，是随机读取

### 查询计划中访问方法的类型

- const：查询条件是主键，并且值是常量

- ref：根据二级索引进行查找，并且执行回表操作，值是常量

- ref_or_null: 找出某个二级索引列的值等于某个常数的记录，还想把该列的值为 NULL 的记录也找出

- range：根据二级索引进行查找，并且执行回表操作，值是一个范围

- all：全表扫描

## MVCC 和 锁

### 事务并发处理可能遇到的问题

- 脏写：事务A和事务B同时修改数据，事务B先修改未提交，然后事务A修改，此时发生脏写

- 脏读：事务A读，事务B修改相同数据，事务B未提交，事务A读到未提交的数据

- 不可重复读：事务A中分两次读取同一条记录：事务A读，事务B修改并提交，事务A再读，两次读取结果不同。

- 幻读：事务A使用查询条件读数据，每次读到的结果行数不同。事务A读，事务B新增、修改并提交，事务B再读，两次读取的结果行数不同。

### 事务的隔离级别

| 隔离级别  | 脏读 | 可重复读 | 幻读 |
| ---      | --- | -----     | ---- |
| 读未提交  | 可能 | 可能       | 可能 |
| 读已提交  | 不可能| 可能      | 可能 | 
| 不可重复读| 不可能 | 不可能 | 可能 | 
| 序列化    | 不可能   | 不可能  | 不可能 |

### MVCC 

- 利用undo日志生成版本链，版本链的头结点是当前最新值（事务可能未提交），根据roller_pointer可以找到历史值（可能提交有可能未提交）

- 生成快照，比较快照中的事务ID，判断该版本是否可见。快照内容包括：

    - 当前活跃的事务ID的集合

    - 当前活跃的事务Id的最小值，小于该Id的事务ID都已提交

    - 创建快照时，下一个事务Id，大于该Id的事务ID都是在本事务之后创建的

    - 创建快照的事务ID

- 读已提交和可重复读常见快照的时机不同

    - 用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView

    - REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView

### 并发事务访问相同记录发生三种情况

- 读-读：允许

- 写-写：加锁

- 读-写：

    - 方案1：读操作利用多版本并发控制（ MVCC ），写操作进行 加锁

    - 方案2：读写均加锁

### 一致性读和锁定读

- 事务利用 MVCC 进行的读取操作称之为 一致性读。常见的select语句都是一致性读

- 加锁读

    - 加读锁 ： select .... lock in share mode;

    - 加写锁: select ... for update;


### 多粒度锁

- 表级锁：针对数据库表

    - X锁

    - S锁

    - IX锁：一个事务在某个表的**一行或多行**上持有排他锁，mysql自动在**表**上加IX锁

    - IS锁：一个事务在某个表的**一行或多行**上持有共享锁，mysql自动在**表**上加IS锁

- 行级锁

    - record-lock

    - gap-lock

    - Next-Key Locks

    - Insert intention locks



### 慢查询优化

- 应用是否向数据库请求了不需要的数据

    - 多表关联返回全部列

    - 总是取出全部列

    - 重复查询相同的数据（应用可以把数据缓存下来）

- mysql是否扫描额外的记录

    - 响应时间

    - 扫描行数

    - 返回行数

### 分库分表

- 性能

- 安全性

| 切分方案 | 解决的问题 |
| ----     | ----     |
| 只分库不分表 | 数据库读写qps过高，连接数不足 |
| 只分表不分库 | 单表数据量过大，存储性能遇到瓶颈 |
| 既分库又分表 | 以上两者   |

### 数据切分方式

- 水平切分：每日表，每月表，历史表

- 垂直切分：将不同的字段切分到不同的表中

### 分表后如何实现数据入库

- 分表算法：根据分表字段确定表名，常见的分表算法有：

    - 取模

    - hash

- 全局ID：分表后全部数据唯一主键如何生成？

    - UUID

    - 多个单表+步长：额外使用多个单表专门生成主键，步长确保多个单表中的主键不会重复

### 列式存储数据库为什么快

1. OLAP和OLTP

    - OLAP（Online Analytical Processing）联机分析处理

    - OLTP（Online Transaction Processing）联机事务处理

2. 列式存储的数据库更适合OLAP型业务，行式存储数据库更适合OLTP型业务。

- 行式存储数据库将一条记录数据存储在一起

- 列式存储数据库将一列数据存储在一起，列式存储数据库执行OLAP任务很快的原因包括

    - 列式存储把相同类型的数据归在一起，可以压缩数据，减少IO（同一列的数据在一个文件中）

    - 除去字符串类型，字段通常是固定长度的，直接读取。而行式存储中，各列字段长度不一致，需要解析

    - 列式存储可以将一个列的一整块数据全部读入内存

3. ck不仅支持分区的过滤也支持列级别的稀疏索引，索引粒度默认是 8192。

### mysql锁的优化策略

1. 读写分离

2. 分段加锁

3. 减少锁的持有时间

4. 多线程尽量以相同的顺序访问数据


### 索引失效的场景以及原因

- 使用左或者左右模糊匹配的时候

- 对索引列使用函数

- 对索引列使用表达式

- 对索引隐式类型转化

- 联合索引非最左匹配

- where子句中的or两侧条件非索引列

### 索引建立需要哪些原则？

- 选择唯一性索引

- 为经常需要排序、分组和联合操作的字段建立索引

- 为常作为查询条件的字段建立索引

- 尽量使用数据量少的索引(索引列的长度小，数据量小，容易比较)

- 尽量使用前缀来索引

- 最左前缀匹配原则，非常重要的原则。


