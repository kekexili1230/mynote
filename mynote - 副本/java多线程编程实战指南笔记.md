<!--
 * @Author: kekexili1230 457738564@qq.com
 * @Date: 2024-02-21 15:55:29
 * @LastEditors: kekexili1230 457738564@qq.com
 * @LastEditTime: 2024-03-20 11:30:50
 * @FilePath: /mynote/java多线程编程实战指南笔记.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# java多线程编程实战指南笔记

## 第二章

### 串行、并发和并行

串行：分别按照顺序执行A、B、C

并发：同时执行A、B、C三件事，时间片轮转方式执行

并行：三个处理器真正同时执行A、B、C三件事。并行是一种更为严格、理想的并发。

### 竟态

并发编程存在竟态问题。什么是竟态？

竞态条件（Race Condition）是指在多线程编程中，多个线程访问共享资源，并且最终的结果依赖于线程执行的相对顺序，但这个顺序是不确定的。竞态条件可能导致程序的行为不符合预期，因为线程的执行顺序可能会影响最终结果。

竟态的两种模式：

- read-modify-write

- check-then-act

### 线程安全性

对象的线程安全性：一个类在单线程环境下能够运行正常，并且在多线程环境下，使用方无须做额外改变也能正常运行，则我们称其是线程安全的。

### 线程安全问题

线程安全问题变现在三个方面：原子性、可见性、有序性

#### 原子性

1. 什么是原子性？

涉及**对共享变量**访问的操作，若操作从其执行线程**以外的任意线程来看是不可分割的**，则该操作就是原子操作。

2. java实现原子性的方式

- 共享变量

    - 锁

    - cas指令

- 基本数据类型

    - 非long/double：读写具有原子性

    - long/double：volatile 修饰可以确保原子性

    - 对任何变量的读操作都具有原子性

**原子操作可以消除竞态**

#### 可见性

1. 什么是可见性问题？

一个线程对共享变量更新后，后续访问该变量的线程可能无法立刻看到这个更新结果，这就是线程安全的可见性问题。

多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据。


2. 为什么存在可见性问题？

和计算机存储系统有关。处理器不是直接读取内存，而是通过寄存器、高速缓存、写缓冲器、无效化队列等部件执行内存读写操作。每一个处理器都有自己的处理器缓存。

3. CPU写数据的顺序是：寄存器 -> 写缓冲器 -> 高速缓存 -> 主内存

4. 什么是缓存一致性协议？

通过缓存一致性协议可以读取其他处理器高速缓存中的数据，并将读到的数据更新到该处理器的高速缓存中，实现**缓存同步**

缓存同步可以使得一个处理器读取到另一个处理器对共享变量所做的更新：

- 冲刷处理器缓存：将处理器对共享变量所做的更新从**写缓冲器**写入**高速缓存**中，这个过程称为flush处理器缓存。冲刷处理器缓存可以确保其他线程读取到共享变量的更新。

- 刷新处理器缓存：处理器在读取共享变量时，如果其他处理器已更新共享变量，本处理器必须从其他处理器的高速缓存中进行缓存同步，这个过程叫做refresh处理器缓存。刷新处理器缓存可以确保读取到最新的共享变量。

**通过冲刷处理器缓存和刷新处理器缓存可以确保可见性**

5. java如何保证可见性？

- volatile

- lock

6. 原子性和可见性的联系区别？

- 原子性可以保证一个线程读取到的共享变量的值要么是变量的初始值要么是相对新值，而不会是一个中间结果。

- 可见性描述的是一个线程对共享变量的更新对另外一个线程而言是否可见。

- 原子性确保线程对共享变量的修改不受干扰；可见性确保其他线程能够及时看到该修改。

#### 有序性

有序性指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在其他线程看来是乱序的。

1. 重排序

在多核处理器环境下，按照代码顺序执行可能是没有保障的：

- 编译器可能改变操作的先后顺序

- 处理器可能不是完全按照程序的目标代码所指定的顺序执行指令

- 一个处理器上执行的操作，在其他处理器看来执行顺序和代码顺序不一致

重排序是对内存访问的优化，在不影响单线程程序正确性的情况下提升程序的性能。

2. 内存操作顺序相关术语：

- 源代码顺序

- 程序顺序：字节码顺序和机器码顺序

- 执行顺序：处理器实际执行顺序

- 感知顺序：其他处理器看到的内存访问顺序

3. 重排序可以分为：指令重排序和内存重排序

##### 指令重排序

java平台包含两种编译器：静态编译器和动态编译器。前者的作用是将java源代码编译为字节码(.class)文件，后者的作用是在运行时将字节码编译为java虚拟机的本地代码（机器码）。动态编译器可能执行指令重排序。

处理器也可能对指令进行重排序，乱序执行。

##### 内存重排序

1. 四种类型的内存重排序：

- loadload重排序：处理器先后执行两个读内存操作L1和L2，其他处理器的感知顺序可能是L2、L1

- storestore重排序：处理器先后执行两个写内存操作W1和W2，其他处理器对这两个内存操作的感知顺序是W2、W1

- loadstore重排序：处理器先执行读操作L1，再执行写操作w2，其他处理器对这两个内存操作的感知顺序是W2->L1

- storestore重排序：处理器先执行写操作W1，再执行读操作L2，其他处理器对这两个内存操作的感知顺序可能是L2->W1

2. 数据依赖关系：两个指令访问同一个变量，且其中一个操作为写操作，则这两个操作之间存在数据依赖关系：

- 写后读

- 读后写

- 写后写

3. 貌似串行语义：存在数据依赖关系的执行不会被重排，这样从单线程的角度保证重排后程序的运行结果不影响程序的正确性，从而给单线程程序造成一种假象，指令是按照源代码顺序执行的。

4. 如何保证内存访问的顺序性？

- 从底层角度来说，通过调用处理器提供的内存屏障来实现

- 从java语言的角度，volatile关键字，sync关键字，lock

5. 可见性和有序性的关系？

- 可见性是有序性的基础。先可见，然后有序

- 有序性影响可见性。重排序后，一个线程对共享变量的更新对于另外一个线程而言可能变得不可见。


### 上下文切换

1. 什么是上下文切换？

一个线程被暂停（被剥夺处理器的使用权），另外一个线程被选中开始或者继续运行的过程就叫做线程**上下文切换**。在进行上下文切换时需要保存和恢复相应线程的进度信息，这个进度信息就被称为**上下文**，一般包括通用寄存器的内容和程序计数器的内容。

2. 什么时候发生上下文切换？

线程在running和非running状态之间切换的过程就是一个上下文切换的过程。

3. 什么会触发上下文切换？

- 自发性上下文切换

    - Thread.sleep

    - Object.wait

    - Thread.yeild

    - thread.join

    - LockSupport.park

- 非自发性上下文切换

    - 时间片用完

    - 优先级更高的线程需要被运行

4. 上下文切换的开销

5. 如何测量上下文切换的开销？

在linux中使用perf命令来监视java程序运行过程中的上下文切换的次数和频次。


## 第三章 java线程同步机制

1. 什么是线程同步机制？

用于协调线程间**数据访问**和**活动**的机制，这些机制用于保障线程安全。

2. 哪些机制用于协调线程间数据访问？

3. 哪些机制用于协调线程间活动？

4. 根据java虚拟机对锁的视线方式划分，java平台的锁包括内部锁和显式锁：

- 内部锁通过sync关键字实现

- 显式锁通过lock接口实现类实现

5. 锁的作用：保证原子性、可见性和有序性

- 保证原子性：通过互斥保证原子性，通过互斥将多线程对共享数据的并发访问改为串行访问。

- 保证可见性：

    - 在java中锁的获取隐含着refresh处理器缓存。读线程获取锁后，可以将写线程修改的更新同步到读线程处理器高速缓存中。

    - 锁的释放隐含着flush处理器缓存。写线程释放锁的时候，对共享变量的修改能够被推送到该线程处理器的高速缓存中。

- 保证有序性：写线程在临界区中所执行的一些列操作在读线程所执行的临界区看起来就像是顺序执行的。

6. 锁相关的概念：

- 可重入性

- 公平锁和非公平锁

- 锁的粒度：保护数据量的大小

7. 锁的开销：

- 申请、释放锁产生的开销

- 导致上下文切换的开销

### 内部锁：sync

java中任意对象都有唯一一个与之关联的锁，被称为监视器锁和内部锁。

作为锁句柄的变量通常采用final修饰，因为变量改变会导致执行同一个同步块的多个线程实际上使用不同的锁。

内部锁是如何调度的？

- 每一个内部锁有一个入口集，存储等待获取内部锁的线程。

- 多个线程申请锁时，成功线程获取锁，失败线程暂停并进入入口集

- 锁被释放是，入口集中任意线程被唤醒和其他未进入入口集的线程抢占锁，成功者获取锁，失败者等待，进入入口集。

### 显式锁：lock

1. 使用函数：lock，unlock，trylock

2. 显式锁和内部锁的比较

- 内部锁是基于代码块的锁

- 显式锁是基于对象的锁；显式锁支持中断，公平锁和超时设置

3. 锁的适用场景（无论是显式锁还是内部锁）

- check-then-act

- read-modify-write操作

### 锁的底层实现：内存屏障

1. java虚拟机如何实现flush和fresh处理器缓存？

通过内存屏障实现。

2. 什么是内存屏障？

内存屏障是一种硬件或软件屏障，用于确保特定顺序的内存访问操作不会被重排序或优化。内存屏障被插入两个指令之间，**禁止编译器和处理器重排序**从而保证有序性，同时这些指令也有副作用**刷新处理器缓存和冲刷处理器缓存**，从而保证可见性。

- 根据可见性保障划分

    - load barrier(加载屏障)：

        - refresh 处理器缓存
        
        - java虚拟机在MonitorEnter（申请锁）之后插入加载屏障

    - store barrier(存储屏障)：

        - flush处理器缓存
        
        - java虚拟机在MonitorExit(释放锁)对应的机器码指令后插入存储屏障。

- 按照有序性保证划分

    - 获取屏障：acquire barrier，

        - monitorEnter包含读操作
        
        - 在读操作（ monitorEnter）之后加入acquire barrier，禁止读操作（ monitorEnter）和屏障之后的读写操作之间重排序。

        - 获取屏障禁止临界区中的读写操作重排到临界区之前

    - 释放屏障：release barrier

        - monitorRelease包含写操作

        - 在写操作（monitorRelease）之前加入release barrier，禁止写操作（monitorRelease）和屏障之前的读写操作之间重排序。

        - 释放屏障禁止临界区中的读写操作重排到临界区之后

结合锁的排他性，一级获取屏障、释放屏障，使得临界区具有原子性。


3. 在一个典型锁结构中，内存屏障和锁的布局如下顺序所示：

- monitorEnter

    - lock，排他性

    - 包含读操作
    
- Load barrier

    - refresh处理器缓存，确保可以读取到最新的值，保证可见性

- acquire barrier

    - 在读操作（moniterEnter）后，禁止临界区代码和moniterEnter重排序，禁止临界区代码排到锁之前

- 临界区：读、写共享变量

- relase barrier
    - 在写操作（MonitorEnter）后，禁止临界区代码和monitorExit重排，禁止临界区代码排到锁之后

- monitorExit

    - unlock，释放锁

    - 包含写操作

- store barrier

    - flush处理器缓存，确保共享变量的修改值刷新到高速缓存中


### 轻量级同步机制：volatile

1. volatile变量不会被编译器分配到寄存器进行存储，对volatile变量的读写操作都是内存访问。

2. volatile可以保证可见性和有序性，但是不能保证写volatile变量的原子性，volatile不会引起上下文切换。

3. volatile的作用：

- 对volatile修饰的double/long类型变量的写操作具有原子性

    - 仅保证对修饰变量的写操作具有原子性，而不表示对volatile变量的赋值操作具有原子性。

- 保证有序性

- 保证可见性

4. 对volatile写操作的内存屏障布局

- release barrier

    - 在对volatile变量写操作后，禁止volatile写操作和该操作之前的任何读写操作进行重排序。保证有序性

- volatile变量写操作

- store barrier

    - flush处理器缓存，确保共享变量的修改值刷新到高速缓存中，确保对其他处理器可见

5. 对volatile读操作的内存屏障布局

- load bariier

    - refresh处理器缓存，确保可以读取到最新的值，保证可见性

- 读volatile变量

- acquire barrier

    - 在读操作后，禁止读操作和和之后的读写操作重排，保证有序性

### volatile变量的开销

volatile变量的读、写操作都不会导致上下文切换。

### 非阻塞同步：CAS

cas只是保障了共享变量更新这个操作的原子性，但是并不保障可见性。因此仍需使用volatile修饰，完整的代码实例如下所示：

```java

public class CASTest {
    private volatile long count;

    public void increment() {
        long oldvalue;
        long newValue;

        do {
            oldValue = count;
            newValue = oldValue + 1;
        } while (!compareAndSwap(oldValue, newValue));

    }
}

```
#### 原子变量类

### 对象逸出















