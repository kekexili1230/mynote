<!--
 * @Author: kekexili1230 457738564@qq.com
 * @Date: 2024-01-21 15:40:27
 * @LastEditors: kekexili1230 457738564@qq.com
 * @LastEditTime: 2024-01-21 19:59:51
 * @FilePath: /mynote/面试答题总结-我的回答/springCloud - 面试回答.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# springCloud

## 什么是微服务？微服务有什么特点？微服务有什么优点？

微服务是一种软件架构风格，它将一个应用程序划分为一组小型、自治的服务，每个微服务都专注于实现特定的业务功能。这些服务可以独立开发、测试、部署、运行，服务服务之间通过轻量级的通信机制相互协作。

- 服务独立性：微服务是独立的、自治的服务单元，每个服务都可以使用不同的技术栈独立开发、测试、部署和扩展。服务之间松耦合。

- 分布式系统：微服务架构通常是一个分布式系统，各个微服务可以运行在不同的服务器、容器或云上。微服务通过轻量级的通信机制进行通信，常见的通信方式包括 HTTP/REST、RPC、消息队列等。

- 单一责任原则：每个微服务专注于实现一个特定的业务功能，遵循单一责任原则。这使得每个服务的代码相对简单、易于维护，有助于快速开发和部署。

- 容错性和弹性设计：微服务架构通常具备容错性和弹性设计，能够更好地处理服务的故障和异常情况

- 去中心化的数据管理：微服务通常拥有自己的数据存储，这避免了单一数据库的性能瓶颈。每个微服务通过 API 提供数据服务，实现了去中心化的数据管理。

独立、分布、单一、容错、去中心

## 微服务和单体应用相比有哪些优点缺点？

- 单体应用

    - 优点：（开发、部署、运行、维护）

        - 简单易维护：单体应用通常结构简单，易于理解和维护。开发人员只需要关注一个代码库和一个部署单元。

        - 开发速度快：在单体应用中，开发人员可以更容易地实现功能，因为整个应用的逻辑在一个代码库中。

        - 部署简单：单体应用的部署通常比微服务应用更为简单，因为只需要部署一个单独的应用。

        - 性能优化：单体应用内部的通信是直接的函数调用，没有通过网络的开销，这可能在一些场景下提供更高的性能。

    - 缺点：
        
        - 扩展性受限：单体应用的扩展性有一定的限制，因为整个应用需要进行水平扩展，而不能只扩展其中的某一部分。

        - 技术栈绑定：单体应用通常使用一种统一的技术栈，这可能导致在某些情况下不方便选择最适合的技术。

- 微服务：

    - 优点：（开发、部署、扩展）

        - 独立部署：微服务架构允许每个微服务独立部署和升级，不影响其他微服务，提高了灵活性和可维护性。

        - 技术栈多样性：微服务架构支持使用不同的技术栈，每个微服务可以选择适合自己的最佳技术。

        - 高扩展性：微服务允许每个服务单独扩展，可以根据需要对某个具体服务进行水平扩展，提高了系统的整体扩展性。

    - 缺点：

        - 复杂性增加：微服务架构引入了分布式系统的复杂性，包括服务发现、负载均衡、分布式事务等方面的挑战。

        - 通信开销：微服务之间的通信通过网络进行，可能引入一定的开销，尤其在跨服务的调用和数据传输上。

        - 一致性难题：在微服务架构中，确保整个系统的一致性变得更加困难，需要采用分布式事务或者其他解决方案。

        - 运维复杂性：微服务架构下的运维和监控需要更为复杂的工具和流程，以确保各个微服务的稳定性和可用性。

## 微服务如何进行拆分？

- 梳理业务和团队成员，明确业务和团队成员的职责

- 业务拆分：

    - 确定业务边界：将微服务划分为业务领域边界内的功能单元，每个微服务负责一个特定的业务领域

    - 单一责任原则：保持每个微服务的简单性和独立性，遵循单一责任原则。每个微服务应该专注于一个具体的功能或业务领域，而不应该包含过多的功能。

- 数据拆分：

    - 如果系统中存在大量的数据，可以考虑根据数据模型的关系将微服务进行拆分。

- 通信成本：考虑微服务之间的通信成本。如果两个功能紧密相关且频繁通信，可能更适合将它们合并为一个微服务，以降低通信开销。

总的原则：高内聚，低耦合，适合团队开发和维护

## 微服务之间如何通信的？

- 同步通信：

    - RPC：微服务可以像调用本地函数一样调用远程服务的方法，常见的架构gRPC

    - http/RESTful APi

- 异步通信：微服务之间通过消息队列进行异步通信，其中一种常见的模式是发布/订阅（Pub/Sub）。一个微服务可以将消息发布到消息队列，其他微服务可以订阅感兴趣的消息。这种方式适用于异步通信和解耦微服务之间的依赖关系。

## 什么是RESTful？

RESTful（Representational State Transfer）表现层状态转化，是一种软件架构风格，主要包含如下概念：

- 资源：在REST中所有的东西都被抽象为资源，每一个资源都有唯一的标识符，通常是URI

- 表现层状态转化：表示客户端和服务器之间的交互是通过资源的表现形式进行的。

    - 资源的状态：源的状态是指资源在特定时刻的属性、数据、关系等信息

    - 资源的表现形式：资源的状态以及与之相关的操作所包含的信息。通常用json或者xml根式表示

- 无状态性：RESTful 架构是无状态的，这意味着每个请求都包含了客户端需要的全部信息。每一个请求都是独立的

- 统一接口：统一接口是RESTful架构的另一个关键原则，它定义了客户端和服务器之间的通信标准。统一接口包含了一组规范，包括资源标识符、资源操作（例如GET、POST、PUT、DELETE等HTTP方法）、表示形式（资源的表现形式）和状态转换（客户端和服务器之间的交互）等。


## spring cloud包含哪些组件

- 服务注册与发现：Eureka

- 配置中心：springCloud config，etcd

- 网关：zuul，kong

- 熔断器：Hystrix

- 客户端负载均衡：Ribbon

- 服务调用：Feign

## 服务注册和发现

### 为什么需要服务注册和发现？

- 动态拓扑管理：微服务架构中的服务数量可能会动态变化，服务的启动、停止或者服务实例的数量变化是常态。

- 服务位置透明：微服务实例通常部署在多个主机和容器中。服务注册和发现提供了一种机制，使得客户端无需事先知道服务实例的确切位置（IP和端口），而是通过注册中心动态地获取服务实例的位置信息。

- 负载均衡：通过服务注册与发现，客户端可以轻松地发现可用的服务实例，并进行负载均衡。

- 故障恢复：当某个服务实例发生故障或宕机时，服务注册中心能够检测到该变化并从注册表中移除相应的实例信息。客户端能够获取到最新的可用实例列表，从而实现故障恢复和系统的健壮性

### 服务注册和发现 - Eureka

#### server单节点如何使用？

- 使用maven引入server依赖包

- 在启动类上使用注解@EnableEurekaServer

- 在配置文件中增加配置信息：自注册

    - server.port

    - spring.application.name 服务名称

    - eureca.client.service-url.defaultZone 自己的地址


#### server集群如何配置？

- 使用maven引入server依赖包

- 在启动类上使用注解@EnableEurekaServer
 
- 在每一个节点配置文件中增加配置信息：相互注册

    - server.port

    - spring.application.name 服务名称，每一个节点保持一致

    - eureca.client.service-url.defaultZone 其他节点的地址

    - eureca.client.instance-name 每一个节点实例的名称

#### client如何使用？

- 使用maven引入client依赖包

- 在配置文件中增加配置信息：

    - server.port

    - spring.application.name 服务名称

    - eureca.client.service-url.defaultZone Eureka的地址（集群地址）

#### Eureka的工作原理

微服务通过Eureka客户端向Eureka服务器注册自身，然后定期发送心跳以保持注册状态。其他微服务通过Eureka客户端查询服务注册表来获取可用服务的信息。Eureka服务器通过定时任务和心跳机制来监控服务实例的状态，保持服务注册表的准确性和实时性。

##### 客户端是如何向服务端注册的？

- Eureka客户端在启动时，首先会创建一个心跳的定时任务，定时向服务端发送心跳信息，服务端会对客户端心跳做出响应，如果响应状态码为404时，表示服务端没有该客户端的服务信息，那么客户端则会向服务端发送注册请求，注册信息包括服务名、ip、端口、唯一实例ID、健康检查url等信息。

##### 服务端是如何保存注册信息的？

服务器在收到注册信息后，将注册信息储存在一个双层结构的Map中，第一层map的key为服务名，第二层的key为具体服务的实例名。


##### 服务失效的方式

- 主动下线：服务实例进行正常的关闭操作时，会触发一个服务下线的REST请求给Eureca Server，注册中心将该服务状态设置为下线(DOWN)，并且把下线事件传播出去。

- Eureca Server 在启动的时候会创建一个定时任务，默认每隔六十秒将当前清单中超时（默认九十秒）没有续约的服务剔除出去。


##### 自我保护机制

默认情况下，如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障(比如网络故障或频繁的启动关闭客户端)，Eureka Server自动进入自我保护模式。不再剔除任何服务，当网络故障恢复后，该节点自动退出自我保护模式。


## 负载均衡 - Ribbon


在Eureka客户端中已经集成了Ribbon服务

### 如何使用Ribbon

使用@LoadBalance注解

### Ribbon负载均衡的原理

一个服务对应多个实例，通过服务发现获取所有服务实例信息，使用负载均衡策略，选择服务实例，进行转发

### 负载均衡的策略有哪些？

- 轮询策略

- 随机策略

- 权重策略：根据每个服务提供者的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性也就越低

- 最小连接数策略：它是遍历服务提供者列表，选取连接数最小的⼀个服务实例。


## 服务调用 Fegin

### 如何使用Fegin

- maven引入open依赖

- 在启动类中增加@EnableFeginClients注解

- 编写客户端，声明远程调用

```java
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(name = "example-service")
public interface ExampleFeignClient {

    @GetMapping("/api/greet")
    String getGreeting(@RequestParam("name") String name);
}

```
配置参数包括服务名称，请求方式，请求路径，请求参数，返回值类型。其中请求路径，请求方式，请求参数的使用方式都参考spring mvc形式。

### Feign性能优化

在配置文件中修改Feign配置

```yaml

feign:
  client:
    config:
      default:
        loggerLevel: none

feign:
  httpclient:
    enabled: true

```

- Feign底层的客户端实现

    - URLConnection：默认实现，不支持连接池

    - Apache HttpClient: 支持连接池

    - OKHttp: 支持连接池

- 日志级别：最好使用basic或者None

    - NONE： 表示禁用日志记录，不输出Feign请求和响应的详细信息。

    - BASIC： 最基本的日志级别，输出请求方法、URL、响应状态码和执行时间。

    - HEADERS： 输出BASIC级别的信息，并在请求和响应中包括标头的详细信息。

    - FULL： 输出最详细的日志信息，包括请求和响应的头部、正文、元数据等。

## 断路器 - Hystrix

### 服务熔断、服务降级、服务限流

- 服务熔断（break）

    - 目的： 服务熔断主要用于防止系统中的故障扩散，当某个服务不可用或响应时间过长时，通过断开请求该服务的调用，避免影响整个系统的稳定性。

    - 实现方式： 服务熔断通过设置一个阈值，当服务的错误率达到或超过阈值时，会触发熔断，后续的请求将不再直接发送到该服务，而是会进行快速失败，直接返回一个预设的降级响应或者抛出异常。一段时间后，系统会尝试再次请求服务，如果服务恢复正常，熔断器会关闭，恢复正常的服务调用。

- 服务降级（fallback）

    - 目的： 服务降级是在面对高负载或异常情况时，为了保障核心业务能够继续提供服务而主动放弃某些非核心或可被降级的功能。

    - 实现方式： 当服务降级被触发时，系统会使用一些简化的逻辑或者默认值来代替原有的复杂业务逻辑。这可以包括返回一个预定义的固定值、返回缓存中的数据、返回空数据等。服务降级的目标是保障核心业务的可用性，尽管在某些情况下可能失去了一些功能的完整性。

- 服务隔离和限流（flowlimit）

    - 目的： 服务限流是为了防止系统因为高并发请求而崩溃，通过限制请求的速率，保护系统的稳定性。

    - 实现方式： 服务限流可以通过设置一个阈值，限制每个服务的请求频率或并发数。当请求达到这个阈值时，后续的请求可能被拒绝，或者排队等待处理。服务限流可以在应用层或者网关层进行，确保系统不会受到过多的请求冲击，从而避免资源耗尽和性能下降。

- 服务隔离：在Hystrix中，可以为每个服务实例配置一个独立的线程池。这样，每个服务的调用都会在自己的线程池中执行，不受其他服务的影响。

### 断路器的使用

- maven引入依赖：hystrix

- 在启动配置文件中增加＠EnableCircuitBreaker

- 在方法上标准＠HystrixCommand 注解，设置降级方法，设置超时时间

### 使用场景

微服务A->B->C，如果A和B正常，C异常，B调用C时线程资源不能释放，进而造成B异常，最后A也异常。此时可以使用断路器。

### 断路器的作用

它的作用是在发生故障时，阻止系统继续调用失败的服务，从而防止故障的蔓延，并提高系统的可用性和稳定性。

- 故障隔离：断路器通过在调用链中引入隔离层，将故障的服务隔离开来，防止故障在整个系统中蔓延。如果某个服务发生故障，断路器会迅速打开，避免继续发起请求，减少资源消耗。

- 降级策略：当某个服务出现故障或响应时间过长时，断路器可以提供降级策略，即返回一个备选的、默认的、简化的响应，而不是等待故障的服务响应。

- 自动恢复：断路器具有自动恢复的机制。在一段时间内如果服务的调用成功率达到一定阈值，断路器将逐渐关闭，恢复对服务的正常调用。

- 实时监控：断路器可以提供实时的监控和统计信息，例如服务的成功率、失败率、响应时间等。这有助于运维人员实时了解服务的运行状况。

- 熔断器状态：断路器有三个状态：关闭（Closed）、打开（Open）、半开（Half-Open）。关闭状态下，正常处理请求；打开状态下，拒绝所有请求，用于快速失败；半开状态下，部分请求会被允许，用于测试服务是否已经恢复。

- 快速失败：断路器能够在故障发生时迅速失败，而不是等待超时。这可以减少系统资源的浪费，提高系统的吞吐量。

### 断路器状态转化

- close -> open : 当请求数超过circuitBreaker.requestVolumeThreshold，并且失败比例超过circuitBreaker.errorThresholdPercentage时，断路器由close变为open 

- open -> half-open: 当断路器在open状态时，拒绝所有的请求，持续circuitBreaker.sleepWindowInMilliseconds时间，处于half-open状态。

- half-open：断路器处理下一个请求，如果请求成功，则将状态设置为close；否则设置为open

## 网关 - zuul

### 网关的作用

- 路由（Routing）：网关允许你定义路由规则，将请求映射到相应的微服务。通过路由配置，可以实现请求的转发、重定向、过滤等功能。

- 负载均衡（Load Balancing）：网关可以支持负载均衡，将请求分发到多个实例或副本的微服务中。这有助于提高系统的性能和可伸缩性。

- 安全性与认证（Security and Authentication）：网关可以用于集中处理安全性和认证，例如对请求进行身份验证、鉴权，添加安全头等。这样可以确保微服务在受到保护的环境中运行。

- 监控与日志（Monitoring and Logging）： 网关可以收集请求和响应的信息，生成日志，进行监控和分析。这有助于了解系统的运行状况，及时发现潜在问题。

- 限流与熔断（Rate Limiting and Circuit Breaking）：网关可以实现限流和熔断机制，防止微服务过载，提高系统的稳定性和可用性。

- 请求转换与协议转换（Request Transformation and Protocol Conversion）：网关可以对请求进行转换，例如修改请求头、请求体的内容，实现请求的转换和适配。同时，它还可以处理不同协议之间的转换。

- 降级（Fallback）：网关可以配置降级策略，当某个微服务不可用时，提供默认的或者预先定义的降级响应，确保系统的可用性。

### 如何使用zuul

- 引入maven依赖

- 在启动类上增加zuul的注解

### zuul的功能 

- 配置路由

    - 基础路由配置：需要在配置文件中做如下配置

        - 路由Id

        - 路由path

        - 路由url

    - 面向服务的路由配置

        - 增加eureka的maven依赖

        - 开启eureka的服务

        - 路由Id

        - 路由path

        - serviceId

### zuul过滤器

zuul还提供过滤器功能，负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。zuul有四种类型的过滤器：

- pre：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请
求的微服务、记录调试信息等。

- routing：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用
Apache HttpClient或Netfifilx Ribbon请求微服务。

- post：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP
Header、收集统计信息和指标、将响应从微服务发送给客户端等。

- error：在其他阶段发生错误时执行该过滤器。

