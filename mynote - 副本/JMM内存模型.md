<!--
 * @Author: kekexili1230 457738564@qq.com
 * @Date: 2024-02-19 11:16:14
 * @LastEditors: kekexili1230 457738564@qq.com
 * @LastEditTime: 2024-02-20 23:25:19
 * @FilePath: /mynote/JMM内存模型.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# JMM多线程内存模型

java内存模型跟CPU缓存模型类似，是基于CPU缓存模型建立的，java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。

## 硬件的效率和一致性（物理机的并发处理方案）

1. 为了解决CPU和存储设备之间的读写速度差异，引入了高速缓存

2. 但是高速缓存会导致“缓存一致性”问题：在多核操作系统中，每个处理器都有自己的高速缓存，同时又共享同一内存，当多个处理器的运算任务都涉及同一块主存区域时，将可能导致各自的缓存数据不一致。

3. intelCPU通过MESI协议解决“缓存一致性”问题


## java内存模型

java内存模型是一种规范，用于屏蔽各种硬件和操作系统的内存访问差异，以实现java程序在各种平台下都能达成一致的内存访问效果。

c/c++直接使用物理硬件和操作系统的内存模型，不同平台上的内存模型差异可能导致相同代码在不同平台上运行结果不同。

## 主内存和工作内存

1. java内存模型的主要目的：定义程序中各种变量的访问规则，即虚拟机把变量值存到内存和从内存中取出变量。此处的变量指实例字段、静态变量以及构成数组对象的元素。

2. java内存模型：

- 主内存：
    
    - 可以类比为物理硬件内存

    - jmm规定所有的变量都存在主内存中

- 工作内存：

    - 每条线程还有工作内存，可以和处理器高速缓存类比

    - 工作内存中保存了被该线程使用的变量的内存副本

    - 线程对变量的所有操作（读、写）都必须在工作内存中进行

    - 不同的线程之间无法直接访问对方内存中的变量，线程间变量的传递需要通过主内存进行。

3. jmm和jvm内存区域的关系

两者基本没有什么关系，如果勉强对应则：

- 主内存 : java堆中对象实例数据部分

- 工作内存：对应与虚拟机栈中的部分区域。

和硬件的对应关系：

- 主存：对应物理硬件的内存

- 工作内存：虚拟机可能会让工作内存优先存储在寄存器和高速缓存中

4. 内存间的交互操作：

java内存模型中定义了8中操作完成变量从主存拷贝到工作内存，从工作内存同步回主存：

- lock：作用于主存变量，把变量标识为一个线程独占

- unlock: 作用于主存变量，释放锁定状态的变量

- read：作用于主存，将变量从主内存读取到工作内存中，以便load使用

- load：作用于工作内存，将read读到工作内存中的变量存入变量副本中

- use：作用于工作内存，将工作内存变量传递给执行引擎，当虚拟机遇到一个需要**使用变量的值**的字节码指令时，将会执行这个动作

- assign：作用于工作内存，把一个从执行引擎接收的值赋给工作内存的变量。当虚拟机遇到给一个给**变量赋值**的字节码指令时执行这个操作

- store：作用于工作内存，将工作内存中的变量传送到主内存中，以便后续的write使用

- write：作用于主内存，将store操作的变量的值存入主内存变量中

5. 内存操作必须满足的规则

- 把变量从主内存拷贝到工作内存，顺序执行read和load操作（read和load之间必须顺序执行，但是不要求连续执行，即两个操作之间可以插入其他操作）

- 把变量从工作内存写入主内存，顺序执行store和write操作（store和write之间必须顺序执行，但是不要求连续执行，即两个操作之间可以插入其他操作）

- 不允许read和load，store和write操作单独出现

- 不允许一个线程丢弃最近的assign操作，变量在工作内存中修改后必须把变化同步回主内存

- 不允许没有发生过assign操作却把数据从工作内存同步回主内存

- 新变量只能在主内存中诞生，不允许在工作内存中直接使用未初始化变量

- 一个变量在同一个时刻只允许一条线程对其进行lock操作，lock操作可以被同一线程重复执行，只有执行相同次数的unlock操作，变量才会被解锁

- 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assign操作以初始化工作内存中的值

- 如果一个变量没有被lock操作锁定，则不允许执行unlock操作

- 对一个变量执行unlock操作前，必须将变量同步回主存中

通过上述规则同一判断哪些内存访问操作在并发下是安全的。

6. 对volatile变量的特殊规则

volatile变量具备两种特性：

- 保证此变量对所有的线程可见，当一个线程修改变量的值，新值对其他线程立即可见。

- 禁止指令重排序优化（重排序优化指的是机器级的优化操作，对应汇编代码优化重排）普通变量仅保证在线程执行过程中**依赖赋值结果的地方**都能获取到正确的结果，但是实际执行顺序和代码中的顺序可能不一致。


7. 如何理解volatile变量不保证原子性？

volatile保证可见性，一个线程修改volatile变量后，必须将变量立即写回主内存。其他线程读取volatile变量时，必须从主存读取，然后执行读写操作。因此volatile具有可见性。但是线程读取后，其他线程仍然可以修改volatile的值，而此时，就可能造成数据异常。举例说明：线程A读取volitle变量执行自增操作，线程B在线程A读取，修改volatile变量的值，并写入主存，线程A完成自增操作，并将volatile变量写会主存，此时发生脏写。

8. volatile变量的使用场景

- 单一线程修改变量的值

- 变量不需要和其他状态变量共同参与不变约束

其他使用场景仍需要加锁。

9. 指令重排在并发编程中的问题：

线程A执行如下命令：x=10;y=11;z=x+y

线程B执行如下命令：if(y=11) print(x);

对于线程A：变量z依赖x和y，因此x=10和y=11一定在z=x+y之前执行，但是x=10和y=11哪个先执行，并不知道。

对于线程B：如果线程A执行顺序是x=10;y=11，则打印10；如果线程A执行顺序是y=11;x=10，则打印结果可能是10，也可能是0

10. volatile变量如何实现可见性？

修改volatile变量A的机器码中会使用lock前缀，lock前缀会在执行指令时锁住内存总线，防止其他处理器同时修改相同的内存地址，同时该前缀将本处理器中变量A的缓存写入内存，写入动作同时引起其他处理器无效化变量A的缓存。其他处理器使用变量A时，只能重新执行store和load操作。

11. volatile如何事项禁止指令重排？

- 什么是指令重排？指令重排是指处理器允许将指令不按照程序规定的顺序进行处理，但是必须能正确处理指令依赖情况，确保得到正确的结果。因此在一个处理器中，重排序过的代码逻辑上依然是有序的。

当对volatile变量进行修改时，java规范确保将对该变量的修改同步到内存，并确保在这个指令之前的所有操作都已经完成。

12. jmm对volatile变量限定的使用规则：

- 线程对volatile变量A的前一个动作是load时，才能对变量A执行use操作（使用前，必须执行read，load操作）； 线程对volatile变量的后一个动作是use时，才能对变量执行load操作（只有在使用时，才能执行read，load操作）；即读取volatile变量，执行操作顺序必须是：read, ..., load, use

- 线程对volatile变量A执行的前一个动作是assgn的时候，才能对变量A执行store动作；只有后一个动作是store时，才能执行assign操作。即修改volatile变量，执行操作顺序只能是：assgin, store, ..., write

13. jmm是围绕着在并发过程中如何处理原子性，可见性和有序性三个特性来建立的，jmm是如何实现三者的：

- 原子性

    - jmm保证对基本数据类型的读写访问（除long和double）都是原子性

    - 提供lock和unlock操作满足更大范围的原子性保证（sync关键字）

- 可见性

    - 普通变量：在工作区修改变量后，写回主存（允许延迟写回）；线程使用变量，可以使用工作区中副本变量（不更新）

    - volatile变量：volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新

    - sync关键字：对一个共享变量执行unlock操作之前，必须先把变量同步回主内存中（执行store、 write操作） ”这条规则获得的。如果对一个共享变量执行lock操作，那将会清空工作内存中此变量的值， 在执行引擎使用这个变量前， 需要重新执行load或assign操作以初始化变量的值

    - final变量：被final修饰的字段在构造器中一旦被初始化完成，其他线程就能看到final字段的值。

- 有序性：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性

14. happens-before原则

happens-before原则用来判断有序性。操作A先行发生于操作B，则操作A产生的影响能够被操作B看到。

- 程序次序性规则：同一线程内

    - 动作不存在数据依赖关系，可以重排

    - 动作存在依赖关系，happens-before

- 内部锁规则：内部锁的释放happens-before后续锁的申请

    - 这里的后续指的是时间上的先后关系

    - 内部锁规则和程序次序性规则可以解决多线程之间的可见性问题    

- volatile变量规则：对volatile变量的写操作happens-before后续的读操作

- 线程启动规则：线程的start方法happens-before被启动线程中的任何一个动作

- 线程终止规则：线程中的任何一个动作happens-before该线程的join方法


## 线程安全

1. 什么是线程安全？

当多个线程访问一个对象时，如果不需要额外的同步，或者进行其他的协调操作，调用这个对象都可以获得正确的结果，这个对象就是线程安全的。

2. 多线程共享的数据可以分为如下几类：

- 不可变对象：一经创建其状态就保持不变的对象。

    - 共享基本类型的数据：定义时使用final修饰

    - 共享对象：

        - 类本身用final修饰，防止创建子类改变定义行为

        - 所有字段都用final修饰

        - 对象在初始化过程中没有逸出

        - 如果字段引用了状态可变的对象，private修饰，返回值进行防御性复制。

3. 如何实现线程安全？

- 同步互斥（阻塞同步）

    - synchronized

        - 代码块结构同步语法（方法或者代码块）  
        
        - 可重入

        - 无条件阻塞后面的线程，无法中断、超时退出和强制已获取锁的线程释放锁

        - 重量级锁：阻塞和唤醒线程需要用户态和内核态的切换

    - reentrantlock

        - 等待可中断

        - 可实现公平锁

        - 锁可以绑定多个条件

        - reentranlock在功能上是sync的超集，性能大致相当，但还是优先推荐使用sync   

- 非阻塞同步

    - 阻塞同步是一种悲观的并发策略，默认为不做同步，那就肯定会出问题。

    - 非阻塞同步是一种乐观的并发策略，基于冲突检测的乐观并发策略。这种并发策略不需要把线程阻塞挂起。

        - 非阻塞同步需要借助硬件级别的同步命令实现

        - cas命令（内存位置，旧预期值，新预期值）

        - cas操作的ABA问题

- 无同步方案

    - 线程本地存储


## 锁优化

- 自旋锁和自适应自旋

    - 自旋锁：挂起线程和恢复线程需要上下文切换，比较耗时。如果锁定状态时间很短，可以使用自旋锁（处理器忙循环），避免上下文的忙循环。自旋等待时间有一定的限制，如果超过指定次数人没有成功，就会使用传统的方式挂起线程

    - 自适应自旋锁：虚拟机自动判定自选等待的次数

- 锁消除：锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。

- 锁粗化：但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗

- 轻量级锁

- 偏向锁








