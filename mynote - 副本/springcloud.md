# 微服务笔记

## 什么是微服务？

微服务是一种软件架构风格，它将一个应用程序划分为一组小型、自治的服务，这些服务可以独立开发、部署、运行，通过轻量级的通信机制相互协作。每个微服务都专注于实现特定的业务功能，并且可以通过独立的代码库、开发团队、部署管道和运行时环境进行管理。

- 服务独立性：微服务是独立的、自治的服务单元，每个服务都可以独立开发、测试、部署和扩展。服务之间是松耦合的，一个服务的变化不应该对其他服务造成影响。

- 分布式系统：微服务架构通常是一个分布式系统，各个微服务可以运行在不同的服务器、容器或云上。微服务通过轻量级的通信机制进行通信，常见的通信方式包括 HTTP/REST、消息队列等。

- 单一责任原则：每个微服务专注于实现一个特定的业务功能，遵循单一责任原则。这使得每个服务的代码相对简单、易于维护，有助于快速开发和部署。

- 独立部署：微服务可以独立部署，每个服务的代码和依赖可以独立更新。这使得团队可以快速响应需求变化，不需要等待整个应用程序的部署。

- 自动化运维：微服务架构通常采用自动化运维的方式，包括自动化部署、自动化测试、自动化监控等。这有助于确保微服务的可靠性和稳定性。

- 去中心化的数据管理：微服务通常拥有自己的数据存储，这避免了单一数据库的性能瓶颈。每个微服务通过 API 提供数据服务，实现了去中心化的数据管理。

- 容错性和弹性设计：微服务架构通常具备容错性和弹性设计，能够更好地处理服务的故障和异常情况。每个微服务的独立性和松耦合性有助于系统在出现故障时部分容错，并支持弹性扩展。

### 单体应用和微服务对比

- 单体应用

    - 优点：

        - 简单易维护：单体应用通常结构简单，易于理解和维护。开发人员只需要关注一个代码库和一个部署单元。

        - 开发速度快：在单体应用中，开发人员可以更容易地实现功能，因为整个应用的逻辑在一个代码库中。

        - 部署简单：单体应用的部署通常比微服务应用更为简单，因为只需要部署一个单独的应用。

        - 性能优化：单体应用内部的通信是直接的函数调用，没有通过网络的开销，这可能在一些场景下提供更高的性能。

    - 缺点：
        
        - 扩展性受限：单体应用的扩展性有一定的限制，因为整个应用需要进行水平扩展，而不能只扩展其中的某一部分。

        - 技术栈绑定：单体应用通常使用一种统一的技术栈，这可能导致在某些情况下不方便选择最适合的技术。

        - 难以拓展团队：随着应用的增长，单体应用的代码库可能变得庞大，难以拓展团队，新成员上手难度较大。

- 微服务：

    - 优点：

        - 独立部署：微服务架构允许每个微服务独立部署和升级，不影响其他微服务，提高了灵活性和可维护性。

        - 技术栈多样性：微服务架构支持使用不同的技术栈，每个微服务可以选择适合自己的最佳技术。

        - 高扩展性：微服务允许每个服务单独扩展，可以根据需要对某个具体服务进行水平扩展，提高了系统的整体扩展性。

        - 团队自治：微服务的独立性使得团队可以更独立地负责某个服务的开发和维护，提高了团队的自治性。
    
    - 缺点：

        - 复杂性增加：微服务架构引入了分布式系统的复杂性，包括服务发现、负载均衡、分布式事务等方面的挑战。

        - 通信开销：微服务之间的通信通过网络进行，可能引入一定的开销，尤其在跨服务的调用和数据传输上。

        - 一致性难题：在微服务架构中，确保整个系统的一致性变得更加困难，需要采用分布式事务或者其他解决方案。

        - 运维复杂性：微服务架构下的运维和监控需要更为复杂的工具和流程，以确保各个微服务的稳定性和可用性。

### 服务如何拆分？

- 业务领域边界：将微服务划分为业务领域边界内的功能单元，每个微服务负责一个特定的业务领域。这有助于降低微服务之间的耦合度，使得微服务更专注于特定的业务逻辑。

- 单一责任原则：保持每个微服务的简单性和独立性，遵循单一责任原则。每个微服务应该专注于一个具体的功能或业务领域，而不应该包含过多的功能。

- 数据拆分：如果系统中存在大量的数据，可以考虑根据数据模型的关系将微服务进行拆分。例如，将订单和库存相关的功能拆分成不同的微服务。

- 依赖关系：了解微服务之间的依赖关系，确保拆分后的微服务之间的依赖关系尽量降低。避免过多的微服务之间相互调用，以减少耦合。

- 通信成本：考虑微服务之间的通信成本。如果两个功能紧密相关且频繁通信，可能更适合将它们合并为一个微服务，以降低通信开销。

- 团队结构：考虑团队的组织结构。每个微服务可以由一个独立的团队负责开发和维护，这有助于团队的自治性和独立性。


### 微服务之间如何通信？

- HTTP/RESTful API：微服务可以通过 HTTP 协议提供 RESTful API 进行通信。每个微服务可以作为一个独立的服务端，其他微服务可以通过发送 HTTP 请求和接收 HTTP 响应来进行通信。这是一种简单、标准化的通信方式，易于理解和实现。

- 消息队列：微服务之间通过消息队列进行异步通信，其中一种常见的模式是发布/订阅（Pub/Sub）。一个微服务可以将消息发布到消息队列，其他微服务可以订阅感兴趣的消息。这种方式适用于异步通信和解耦微服务之间的依赖关系。

- RPC（Remote Procedure Call）：使用远程过程调用（RPC）框架，微服务可以像调用本地函数一样调用远程服务的方法。gRPC 是一个流行的 RPC 框架，它使用 Protocol Buffers（protobuf）进行数据序列化，支持多种语言。

### RPC和http之间的区别

- RPC是一种思想，可以使用http协议实现RPC

- RPC基于tcp协议，http基于http协议

- RPC效率更高，Http效率低一点。

## 服务注册和发现

### 为什么需要服务注册和发现？

- 动态性和弹性：在微服务架构中服务的实例可以动态地启动、停止或扩展。通过服务注册和发现，新的服务实例可以注册自己，并使得其他服务能够发现并与其通信。

- 服务位置透明：微服务通常部署在多个主机和容器中。服务注册和发现提供了一种机制，使得客户端无需事先知道服务的确切位置，而是通过注册中心动态地获取服务的位置信息。

- 负载均衡：服务注册中心通常会记录多个服务实例的信息，包括它们的地址和状态。通过负载均衡算法，客户端可以从多个可用实例中选择一个来发起请求，以实现负载均衡。

- 故障恢复：当某个服务实例发生故障或宕机时，服务注册中心能够检测到该变化并从注册表中移除相应的实例信息。客户端能够获取到最新的可用实例列表，从而实现故障恢复和系统的健壮性。

- 服务版本管理： 在微服务架构中，服务的不同版本可能同时存在。通过服务注册和发现，客户端可以选择特定版本的服务实例，以实现灵活的版本管理和无缝的升级。

### Eureka

作用是注册和发现各个SpringBoot微服务，并且提供监控和管理的功能。

- 引入Eureka模块的包，在启动类上增加注解@EnableEurekaServer。

- 在配置文件中配置：

    - spring.application.name：配置应用程序服务名称，属性通常被用于在分布式系统中进行服务注册、服务发现和负载均衡。

    - eureka.client.serviceUrl.defaultZone: 配置ureka服务地址，向该地址注册


### Eureka的工作原理

微服务通过Eureka客户端向Eureka服务器注册自身，然后定期发送心跳以保持注册状态。其他微服务通过Eureka客户端查询服务注册表来获取可用服务的信息。Eureka服务器通过定时任务和心跳机制来监控服务实例的状态，保持服务注册表的准确性和实时性。

#### eureka客户端向服务器注册信息

Eureka客户端会在启动时向Eureka服务器注册信息，注册信息包括：

- 服务名

- 实例ID

- IP地址和端口号信息

- 健康检查url

- 状态

注册成功后，Eureka客户端会定期（默认每30秒）向Eureka服务器发送心跳请求，以表明自己仍然处于活跃状态。

#### eureka如何监控微服务的状态

- 心跳机制：eureka client会定期向服务器发送心跳信息，表明它的活跃状态。

- 定期健康检查：Eureka服务器定期执行健康检查，通过访问health-check-url检查服务实例的健康状态，如果健康检查失败，Eureka服务器可能会将服务实例标记为不健康。

#### eureka如何维护本地服务注册表

- Eureka客户端库会定期（默认每30秒）从Eureka服务器获取最新的服务注册表信息，并将其缓存在本地

- 注册事件通知：当服务实例的状态发生变化时（例如服务注册、注销或实例状态变化），Eureka服务器会发送事件通知给所有注册的Eureka客户端，确保信息的及时性。

## 服务负载与调用

### Feign

#### Feign性能优化

1. Feign底层的客户端实现

- URLConnection：默认实现，不支持连接池

- Apache HttpClient: 支持连接池

- OKHttp: 支持连接池

2. 日志级别：最好使用basic或者None


## 断路器

### 使用场景

微服务A->B->C，如果A和B正常，C异常，B调用C时线程资源不能释放，进而造成B异常，最后A也异常。此时可以使用断路器。

### 断路器的作用

它的作用是在发生故障时，阻止系统继续调用失败的服务，从而防止故障的蔓延，并提高系统的可用性和稳定性。

- 故障隔离：断路器通过在调用链中引入隔离层，将故障的服务隔离开来，防止故障在整个系统中蔓延。如果某个服务发生故障，断路器会迅速打开，避免继续发起请求，减少资源消耗。

- 降级策略：当某个服务出现故障或响应时间过长时，断路器可以提供降级策略，即返回一个备选的、默认的、简化的响应，而不是等待故障的服务响应。

- 自动恢复：断路器具有自动恢复的机制。在一段时间内如果服务的调用成功率达到一定阈值，断路器将逐渐关闭，恢复对服务的正常调用。

- 实时监控：断路器可以提供实时的监控和统计信息，例如服务的成功率、失败率、响应时间等。这有助于运维人员实时了解服务的运行状况。

- 熔断器状态：断路器有三个状态：关闭（Closed）、打开（Open）、半开（Half-Open）。关闭状态下，正常处理请求；打开状态下，拒绝所有请求，用于快速失败；半开状态下，部分请求会被允许，用于测试服务是否已经恢复。

- 快速失败：断路器能够在故障发生时迅速失败，而不是等待超时。这可以减少系统资源的浪费，提高系统的吞吐量。

### 断路器状态转化

- close -> open : 当请求数超过circuitBreaker.requestVolumeThreshold，并且失败比例超过circuitBreaker.errorThresholdPercentage时，断路器由close变为open 

- open -> half-open: 当断路器在open状态时，拒绝所有的请求，持续circuitBreaker.sleepWindowInMilliseconds时间，处于half-open状态。

- half-open：断路器处理下一个请求，如果请求成功，则将状态设置为close；否则设置为open

### 如何使用断路器

- maven引入依赖：hystrix

- 在启动配置文件中增加＠EnableCircuitBreaker

- 在方法上标准＠HystrixCommand 注解，设置降级方法，设置超时时间

## 网关

### 网关的作用

- 路由（Routing）：网关允许你定义路由规则，将请求映射到相应的微服务。通过路由配置，可以实现请求的转发、重定向、过滤等功能。

- 负载均衡（Load Balancing）：网关可以支持负载均衡，将请求分发到多个实例或副本的微服务中。这有助于提高系统的性能和可伸缩性。

- 安全性与认证（Security and Authentication）：网关可以用于集中处理安全性和认证，例如对请求进行身份验证、鉴权，添加安全头等。这样可以确保微服务在受到保护的环境中运行。

- 监控与日志（Monitoring and Logging）： 网关可以收集请求和响应的信息，生成日志，进行监控和分析。这有助于了解系统的运行状况，及时发现潜在问题。

- 限流与熔断（Rate Limiting and Circuit Breaking）：网关可以实现限流和熔断机制，防止微服务过载，提高系统的稳定性和可用性。

- 请求转换与协议转换（Request Transformation and Protocol Conversion）：网关可以对请求进行转换，例如修改请求头、请求体的内容，实现请求的转换和适配。同时，它还可以处理不同协议之间的转换。

- 降级（Fallback）：网关可以配置降级策略，当某个微服务不可用时，提供默认的或者预先定义的降级响应，确保系统的可用性。

### 如何使用zuul

- 引入maven依赖

- 在启动类上增加zuul的注解@EnableZuulProxy，该注解已经包含断路器

#### zuul的功能 

- 配置路由

    - 基础路由配置：需要在配置文件中做如下配置

        - 路由Id

        - 路由path

        - 路由url

    - 面向服务的路由配置

        - 增加eureka的maven依赖

        - 开启eureka的服务

        - 路由Id

        - 路由path

        - serviceId

#### zuul过滤器

zuul还提供过滤器功能，负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础。zuul有四种类型的过滤器：

- pre：这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请
求的微服务、记录调试信息等。

- routing：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用
Apache HttpClient或Netfifilx Ribbon请求微服务。

- post：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP
Header、收集统计信息和指标、将响应从微服务发送给客户端等。

- error：在其他阶段发生错误时执行该过滤器。


### springcloud gateway

#### Spring Cloud Gateway和zuul的对比 

- 生命周期和社区支持

    - Spring Cloud Gateway： 是Spring Cloud生态系统的一部分，受到Spring社区的广泛支持，有着更好的生命周期和更新。

    - Zuul是网飞出品，在Spring Cloud 2.x版本中被标记为不建议使用。

- 实现和技术栈

    - spring cloud gateway使用webflux中的reactor-netty响应式编程组件，底层基于netty框架，支持非阻塞式IO，支持长连接

    -  基于Servlet技术栈，使用阻塞式I/O，不支持长连接

- 性能和扩展

- 路由配置：

    - Spring Cloud Gateway： 路由配置采用声明式的方式，使用YAML或者Java代码配置，更为直观和简单。

    - Zuul： 采用属性配置的方式，需要在配置文件中指定路由规则。

#### spring cloud gateway的功能

- 反向代理

- 鉴权

- 流量控制

- 熔断

- 日志监控

- 路由转发

## 配置中心

## 服务总线
