<!--
 * @Author: kekexili1230 457738564@qq.com
 * @Date: 2024-02-23 15:13:48
 * @LastEditors: kekexili1230 457738564@qq.com
 * @LastEditTime: 2024-03-20 13:27:19
 * @FilePath: /mynote/深入理解java虚拟机.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 深入理解java虚拟机

## 前言

常用的jvm调优参数如下：

- -Xss: Thread stack size（线程栈容量）

- -Xms: initial heap size 初始堆大小，它指定Java虚拟机在启动时分配给堆的初始内存大小

- -Xmx: Maximum heap size 最大堆大小，它指定Java虚拟机堆的最大内存大小。

- -XX: +HeapDumpOnOutOfMemoryError 可以让虚拟机在出现内存溢出时dump当前内存快照

- -XX: +PrintGCDetails 在发生垃圾收集行为时打印内存回收日志 

- -XX：PretenureSizeThreshold参数，大于该值的对象直接在老年代

- -XX: MaxTenuringThreshold 设置晋升老年代的年龄阈值。


## 第二章 java内存区域与内存溢出异常

### 2.1 运行时数据区域

1. java虚拟机所管理的内存包含运行时区域如下：

- 线程共享区：

    - 方法区

    - 堆

- 线程隔离区

    - 虚拟机栈：描述java方法执行的线程内存模型。

        - 每个方法执行，虚拟机会创建一个栈帧，存储：**局部变量表，操作数栈，动态连接，方法出口**。方法从调用到执行完毕，对应栈帧的入栈和出栈。

    - 本地方法栈

    - 程序计数器：当前线程所执行的字节码的行号指示器，用来表示下一条需要执行的字节码指令。

        - 执行java方法：计数器记录虚拟机字节码指令的地址

        - 执行Native方法：计数器为空

        - 唯一不会存在OOM的区域

2. java虚拟机栈

- java虚拟机栈的用途是什么？
    
    描述java方法执行的内存模型。每一个方法对应一个栈帧，站帧内容包括：局部变量表、 操作数栈、 动态连接、 方法出口等信息。

    - 局部变量表

        - 局部变量表存储哪些内容？

            局部变量表存储编译期可知基本数据类型、对象引用和返回地址类型

        - 局部变量表如何存储？

            局部变量表使用局部变量槽存储数据，局部变量槽的长度为32位。
            
        - 局部变量表的大小如何确定？

            当程序编译完成，进入方法时，该方法中的局部变量完全已知，因此局部变量表的大小完全确定

    - 如果请求栈深度超过虚拟机允许的深度，则将抛出StackOverflowError

    - 如果虚拟机栈容量可以动态扩展，扩展时无法申请到足够的内存，则会抛出OOM错误

- java虚拟机栈的生命周期是什么？

    和线程相同

- java虚拟机栈可能抛出的异常类型？

    - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常。

    - 如果虚拟机栈允许动态扩展，但扩展时无法申请到足够的内存时，抛出OOM异常

3. 本地方法栈

- 什么是本地方法栈？

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

- 本地方法栈可以抛出哪些异常？

本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。

- 本地方法栈的生命周期？

    和线程相同

4. java堆

- java堆的用途？

    java堆被所有的线程共享，用于存放对象实例。

- java堆是垃圾收集器管理的内存区域

- 什么是TLAB（Thread Local Allocation Buffer）？

    - 所有线程共享的堆可以划分出多个线程私有的分配缓冲区，提升对象的分配效率。

    - 但是无论如何划分，堆仍然是所有线程共享，用于存放对象实例。

- 如果设置扩展堆的大小？

    通过参数-Xmx和-Xms设定。其中-Xmx表示最大堆大小，-Xms表示初始化堆大小。

    - 通常将-Xms（初始堆大小）和-Xmx（最大堆大小）设定相同的原因是什么？

        - 避免程序在运行过程中频繁调整堆的大小，这个过程存在一定的开销：需要GC和对象迁移。

        - 一致性的堆大小更容易检测和诊断内存泄漏情况。

- java堆中会抛出什么异常？

如果没有足够的内存为对象分配空间，并且java堆也无法扩展时，抛出OOM异常

5. 方法区（别名非堆，Non-Heap）

- 方法区的作用是什么？

    方法区是各个线程共享的内存区域，用于存储类的结构信息、静态变量信息、常量、类方法等数据。


- 什么是运行时常量池？

    Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。常量池的作用包括：

    - 存储字符串常量：包括在代码中直接出现的字符串，以及由String类创建的字符串对象。

    - 存储基本数据类型的常量：例如整数、浮点数等。

    - 存储符号引用：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符等。

- 方法区可以抛出哪些异常？

    方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

    - 类太多，造成方法区无法容纳类的元数据

    - 大量的字符串常量，存储在运行时常量池中

    - 大量的静态变量和常量

    - 动态代理类

- 运行时常量池的作用是什么？

    运行时常量池用于存放编译期生成的各种字面量和符号引用

    - 字面量：字符串，常数

    - 符号引用：对类，字段，方法的引用（变量名，字段名）

6. 直接内存

- 什么是直接内存？

直接内存（Direct Memory）是一种在Java中使用非堆外部内存的方式，它通常是通过java.nio包中的ByteBuffer或者相关的类来进行操作。直接内存并不是Java虚拟机管理的堆内存，而是由操作系统分配和管理的一块内存区域。

在Java中，通过直接内存可以利用操作系统提供的零拷贝特性，使得在进行I/O等操作时能够更加高效。一般来说，直接内存的使用场景包括对文件的映射、网络传输、以及需要零拷贝的大规模数据处理等。

- 直接内存不是虚拟机运行时数据区的一部分。

- 本机直接内存的分配不会受到Java堆大小的限制，受本机总内存的限制。

### 2.2 虚拟机对象探秘

探讨一下HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。

1. 对象的创建

- 遇到new指令，检查指令参数是否是常量池中的类符号引用，并检查符号所代表的类是否被加载、解析以及初始化。如果没有则加载类

- 分配内存空间。分配完成后，将内存空间初始化为0（实例对象默认初始化）

- 对对象进行设置：

    - 确定实例所属的类

    - 对象的哈希码

    - 对象的GC分代年龄等。

- 从jvm的角度，对象已经产生。但是从java应用程序的角度，仍需要执行**构造函数**

2. 对象的内存布局

对象在堆内存中的布局分为三个部分：

- 对象头

    - 第一部分，存储对象自身的运行时数据：哈希码，GC分代年龄，锁状态，线程持有的锁，偏向线程ID等。

    - 第二部分，类型指针，对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例。

- 实例数据：字段内容，父类继承字段和子类定义字段

- 对齐填充：对齐填充

3. 对象的访问定位

使用reference引用

### 2.3 OOM异常分析

1. java堆溢出

java堆溢出的条件：

- 对象数量不断增加

- GC roots到对象之间有可达路径

2. 虚拟机栈和本地方法栈溢出

虚拟机栈和本地方法栈有两种异常：

- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。

- 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时， 将抛出OutOfMemoryError异常。HotSpot虚拟机不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的。

3. 方法区和运行时常量池溢出

4. 本机直接内存溢出


## 第三章

### 3.1 判断对象存活的算法

判断对象是否存活的算法有哪些？

- 引用计数法

    - 缺点：无法分析相互引用

- 可达性分析算法

    - 通过"GC Root"的根对象作为起点，根据引用关系向下搜索。从图论的角度来说，从GC root到这个对象不可达时，证明这个对象不可能再被引用。

    - GC root对象包括

        - 虚拟机栈栈帧中的参数、局部变量、临时变量

        - 方法区中类静态属性引用的变量

        - java虚拟机内部的引用

        - 被同步锁持有的对象
    
    这些GC Root对象构成GC root集。

方法区的垃圾回收主要回收哪些内容？

- 废弃的常量：例如运行时常量池中的定义的字符串常量（局部变量赋值使用字符串常量）

- 不再使用的类型

    如何判断类型不再被使用？

    - 该类所有的实例都被回收

    - 该类的加载器都被回收

    - 该类的Class对象没有在任何地方被引用

    如果满足上述条件，java虚拟机允许对类进行回收

### 3.2 垃圾收集算法

1. 垃圾收集器遵循"分代收集"理论进行设计：

- 弱分代假说：绝大多数对象都是瞬态的

- 强分代假说：熬过多次垃圾收集过程的对象就难以消灭

- 跨代引用假说：跨代引用相对于同代引用比较少

2. 根据上面的理论引出垃圾收集器的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

3. 具体而言，在java虚拟机中，将java堆分为

- 新生代

- 老年代

4. 每个区域中存储对象存亡特性不同使用不同的算法：

- 标记-清除算法：先标记所有需要回收的对象，然后统一回收

    - 缺点：内存碎片

- 标记-复制算法：将内存划分为大小相等的两块，每次使用一块。当一块内存用完了，就将存活的对象复制到另外一块上，然后一次性清除本区域。

    - 缺点：将内存缩小一般，空间利用率低

- 标记-整理算法：先标记所有存活的对象，然后将存活对象移动到存储空间的一端，最后清理掉其他区域。

    - 缺点：移动大量对象和更新引用非常消耗性能，同时移动对象时必须全程暂停应用程序（stop the world）。
    

5. GC有哪些分类？

- 部分收集（partial gc）：指目标不是完整收集整个java堆的垃圾收集

    - 新生代收集（Minor GC）：目标新生代的垃圾收集

    - 老年代收集（Major GC）：目标老年代的垃圾收集

    - 混合收集（Mixed GC）：目标新生代和部分老年代的收集

- 整堆收集（full GC）：收集整个java堆和方法区的垃圾收集

### 3.3 应用

1. java中的引用，引用强度依次减弱：

- 强引用

    - Object obj = new Object()这种引用关系

    - 强引用关系在，垃圾收集器就不会回收

- 软引用

    - 用来描述还有用，但是非必须得对象。

    - 在系统将要发生内存溢出前，会对这些对象列进回收范围，进行二次回收，如果仍没有足够的内存，则抛出OOM异常

    - 如何理解上面的二次回收？

        - 第一次回收：当系统内存即将耗尽时，垃圾收集器会检查软引用关联的对象，并将这些对象标记为“即将回收”，此时软引用对象没有被回收

        - 第二次回收：在第一次回收后，系统仍没有足够的内存，垃圾收集器会检查标记为"可回收状态"的对象。

- 弱引用

    - 用来描述非必须对象，强度比软引用更弱

    - 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。弱引用关联的对象在垃圾收集时会被立即回收，而不会像软引用那样经历两次回收的过程

- 虚引用

    - 最弱的一种引用关系

### 3.4 内存分配和回收

1. 对象的内存分配位置在哪里？

对象的内存分配都在堆上，在经典分代设计中，新生对象通常会分配在新生代中，少数情况下（较大对象）可能直接分配在老年代。

2. 内存分配的原则有哪些？

- 对象在新生代Eden区中分配，当Eden区没有足够的内存时，虚拟机将发起monitor GC

- 大对象，需要大量连续存储空间的java对象，例如大数组和大字符串。

    - 程序中应该避免大对象和大对象的复制，会导致提前触发GC，已经内存复制开销。

    - 大对象应该在老年代，避免在Eden区、Survior区、老年区之间复制数据

- 长期存活的对象将进入老年代

    对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。

- full GC

    在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。否则可能执行full GC。

3. 什么时候会触发GC？

- 当Eden区没有足够的内存进行分配时，虚拟机将发起一次Minor GC

- 当老年代空间不足，将触发Full GC

- 当永久代空间不足，会触发full GC

- System.gc调用，请求垃圾回收，具体行为由虚拟机决定

### 3.5 选择合适的GC

选择适合GC的参考标准：

- 应用程序关注点是什么？

    - 数据分析、科学计算类的任务，目标尽快算出结果，需要关注吞吐量

    - 如果是SLA应用（例如阿里云），那停顿时间直接影响服务质量，严重的甚至会导致事务超时， 主要关注延迟

    - 如果是嵌入式应用，那垃圾收集的内存占用则是不可忽视的

- 应用程序的基础设施（硬件）？

- JDK的版本号？

### 垃圾收集过程中的一些关键指标

1. 衡量垃圾收集器的三个指标

- 内存占用

- 吞吐量

- 延迟

其中延迟的重要性越来越凸显

1. 停顿时间

什么是垃圾收集的停顿时间？

在进行垃圾收集时，整个应用程序在进行垃圾收集期间无法继续执行的时间，应用程序的执行被暂停的时间。

有几种停顿时间？

- Minor GC 停顿时间

    Minor GC期间，通常会有一些短暂的暂停，暂停时间较短不会对应用程序的性能产生明显影响。

- Full GC 停顿时间

    full GC 停顿时间较长，会对整个应用程序的性能和用户体验产生明显的影响。


    
### CMS收集器（concurrent Mark Sweep）

1. CMS收集器的优点有哪些？

CMS收集器的显著特点是以最短回收停顿时间为目标的收集器。

2. CMS收集器适用于哪些服务和使用场景？

互联网网站和基于浏览器的B/S系统服务器，关注服务响应速度，希望系统挺短时间尽可能短。

3. CMS收集器的运作过程是？

- 初始标记

    - 停顿线程
    
    - 标记GC root对象

- 并发标记

    - 无须停顿线程，可以和用户线程一起执行

    - 从GC Roots对象开始并发标记所有关联对象

- 重新标记

    - 停顿线程

    - 修正并发标记阶段，用户线程导致并发标记变动的对象

- 并发清除

    - 不需停顿线程

    - 清理掉标记为已死亡的对象

4. CMS收集器的缺点

- 并发阶段占用额外线程，挤占应用程序所需要的资源

- 存在浮动垃圾。并发标记阶段和并发清除阶段，用户线程并发执行，可能产生新的垃圾，这部分垃圾称为“浮动垃圾”。浮动垃圾存在，造成GC不充分

- CMS基于标记清除算法，存在内存碎片

### Garbage First收集器（G1收集器）






## 第四章 虚拟机性能监控

### 4.1 故障定位处理工具

- 基础工具

    - jps：查询本地虚拟机唯一Id

    - jstat: 本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据

    - jmap：生成堆转储快照dump文件

    - jstack：生成虚拟机当前时刻的线程快照

- 可视化工具

    - Java visual VM

    - JConsole

## 第五章 性能调优


## 第六章 类文件结构

1. java虚拟机和平台无关，语言无关，如何理解？

java虚拟机不与java语言绑定，只和Class文件（字节码文件）绑定。其他语言如果能翻译成字节码，也可以使用java虚拟机运行。

### 6.3 class文件的结构

1. class文件的来源有哪些？

类文件、接口文件、动态代理生成

2. class文件采用**类C语言结构体**格式来存储数据，有两种数据类型：

- 无符号数，u1,u2,u4分别表示1个字节，2个字节，4个字节

- 表是由多个无符号数和其他表构成的复合数据类型，表的命名习惯以“_info”结尾。

3. class类文件的结构

- 魔数

- 主版本

- 副版本

- 常量池

- 访问标志

- 类索引、父类索引、接口索引集合

- 字段表集合

- 方法表集合

- 属性表集合


4. 常量池

常量池中主要存放哪些内容？

- 字面量：例如文本字符串，final类型的常量

- 符号引用：

    - 被模块导出的包

    - 类和接口的全限定名

    - 字段的名称和描述符

    - 方法的名称和描述符

    - 方法句柄和类型

    - 动态调用点和动态常量

5. 访问标志

访问标志用于确定类或者接口层次的访问信息，例如接口还是类，是否为public类型，是否为abstract类型，是否为final

6. 类索引、父类索引、接口索引集合

类索引、父类索引、接口索引集合的作用是什么？

这三项数据用于确定该类型的继承关系：

- 类索引确定类的全限定名

- 父类索引确定父类的全限定名

- 接口索引确定实现了哪些接口

7. 字段表集合

字段表集合的作用是什么？

字段表（field_info）用于描述接口或者类中声明的变量。包括类变量和实例变量

8. 方法表集合

方法表集合用于存储访问标志、名称索引、描述符索引、属性表集合。

9. 属性表集合

class文件，字段表，方法表都可以携带自己的属性表集合。

### 6.4节 字节码指令

java虚拟机指令由操作码和操作数构成。操作码占一个字节


### 字节码和数据类型

在操作码助记符中都有特殊的字符来表明为哪种数据类型服务，例如iload，表示加载int类的数据到操作数栈。

### 加载和存储指令

load操作用于将**局部变量**加载到**操作数栈**中：iload, lload

store操作用于将数据从操作数栈存储到局部变量表：istore，lstore

将一个常量加载到操作数栈：bipush, sipush, ldc


## 第七章 类的加载机制

1. 一个类的生命周期有哪些阶段？

- 加载

- 连接

    - 验证

    - 准备

    - 解析

- 初始化

- 使用

- 卸载

2. 类什么时候开始初始化的？

    - 遇到n ew，getstatic，putstatic，invokestatic这四条字节码指令的时候。

        - 使用new关键字实例化对象的时候

        - 读取或者设置一个类型的静态字段

        - 调用静态方法

    - 使用reflect包对类型进行反射的时候

    - 初始化类时，初始化其父类

    - 虚拟机启动时，用户需要执行一个主类

3. 哪些情况不会造成类的初始化？

    - 通过子类引用父类的静态字段，只会触发父类的初始化而非子类。只有直接定义这个静态字段类才会被初始化

    - 创建一个对象数组，数组元素实现类不会被初始化。通过数组定义引用类，不会造成类的初始化

    - 引用定义常量的类（static string s= xxx），不会触发定义类的初始化。

### 类的加载过程

#### 加载

加载的步骤有哪些？

- 通过类的全限定名来获取定义类的二进制字节流

    没有指明从哪里获取，如何获取，常见的应用有
    
    - 从zip压缩包获取（jar, ear, war）

    - 从网络中获取（web applet）

    - 运行时计算机生成（动态代理）

    - 其他文件生成（jsp文件生成class文件）

- 将字节流锁代表的静态数据结构转为为方法区运行时数据结构

- 在内存中生成一个代表这个类的class对象。

不同数据类型的加载阶段？

- 对于非数组类型，通过类加载器完成

- 对于数组类型

    - 数组类由java虚拟机直接在内存中动态创造

    - 元素类型仍依靠类加载器完成

#### 验证

验证阶段主要确保class文件符合java虚拟机规范的全部约束要求。

- 文件格式验证：验证字节流是否符合class文件格式规范

    - 是否已魔数开头

    - 主次版本号是否在接受范围内

    - 常量池中的常量是否支持？

    - 指向常量的索引值是否指向正确（常量是否存在）？

- 元数据验证：对字节流描述的信息进行语义分析

    - 该类是否有父类？

    - 该类是否继承了不被允许的类？

    - 是不是抽象类

    - 类中字段，方法是否与父类产生矛盾

#### 字节码验证

#### 引用符号验证

### 准备阶段

    将对象实例初始化为零值

### 解析阶段

### 初始化阶段

初始化阶段是类加载过程的最后一个步骤，执行类构造器<clinit>()方法。<clinit>() 方法是一个特殊的方法，由编译器自动生成，用于执行类的静态初始化代码块和静态变量的赋值操作。

在多线程环境中<clinit>()方法如何执行？

java虚拟机保证一个类的<clint>()方法在多线程环境中被正确加锁同步，如果多个线程同时初始化一个类，则只会有一个线程去执行这个类的<clinit>()方法，其他线程阻塞，且唤醒后不再进入<clinit>方法中

### 7.4 类加载器

1. 类和类加载器的关系如何？

- 类加载器加载类的class文件

- 类和类加载器共同确定在虚拟机中唯一性。即比较两个类是否相等，必须同时比较类和类加载器。

2. 什么是三层类加载器？

    - 启动类加载器（bootstrap class loader）

        - 启动类加载器复杂加载JAVA_HOME/lib目录下的类库，而且按照文件名识别。     

    - 扩展类加载器（extention class loader）

        - 扩展类加载器可以用来加载JAVA_HOME/lib/ext目录中中的所有类库

        - 允许用户将通用性的类库放在ext目录以扩展java SE的功能。

    - 应用程序类加载器（application class loader）

        - 负责加载用户类路径上的所有类库

    - 自定义类加载器

        - 用户自己实现，可以加载磁盘位置之外的class文件，或者通过class加载器实现类的隔离、重载功能。

3. 什么是双亲委派模型？

双亲委派模型要求除了顶层的启动类加载器外，其他加载器都有自己的父类加载器。父子关系不是通过继承实现，而是使用组合方式实现。

4. 双亲委派模型的工作过程是？

如果一个类加载器收到了类的加载请求，首先不会自己去加载类，而是委托给父类去完成，最终都应该委托给启动类加载器去加载。只有当父类无法加载时，子加载器才会去加载。

5. 双亲委派模型的好处？

java中的类随着类加载器一起具备了优先级的层次关系。典型例子就是Object类，确保rt.jar中的Object类是所有类的唯一父类。


## 虚拟机字节码执行引擎















 





