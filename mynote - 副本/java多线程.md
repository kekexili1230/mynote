<!--
 * @Author: kekexili1230 457738564@qq.com
 * @Date: 2024-02-04 21:26:04
 * @LastEditors: kekexili1230 457738564@qq.com
 * @LastEditTime: 2024-02-16 22:37:01
 * @FilePath: /mynote/java多线程.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 多线程编程

## 多线程核心数的选择

1. 对于CPU密集型线程，可以将线程数设置为N，或者N+1

2. 对于I/O密集型线程，I/O操作可能导致上下文切换，如果一个工作线程就可以满足需求，就不需要更多的线程数。如果一个工作线程不管用，可以考虑将线程的数量设置为2N。

3. 考虑目标处理器的使用率（75%），则公示如下$ N = N_{cpu} * U_{cpu} * (1 + \frac{wt}{st}) $，wt表示程序花费在等待I/O上的时长，ST为程序实际占用处理器执行计算的时长（除了IO时间）。

4. 考虑其他稀缺资源：如数据库连接，文件句柄数连接，网络连接等。

## 上下文切换

一个线程被暂停，另外一个线程被选中开始或者继续运行的过程就叫做线程上下文切换：

- 切出：一个线程被剥夺处理器的使用权而被暂停运行

- 切入：一个线程被选中用处理器开始或者继续运行

在切出或者切入的时候操作系统需要保存和恢复相应的线程的进度信息，该进度信息就被称为上下文，包括：通用寄存器和程序计数器。切出时，操作系统将上下文信息保存到内存中，切入时则从内存中加载被选中的上下文。

从java应用的角度，一个线程的生命周期在running状态和非running状态（blocked，waiting，timed_waiting）之间切换的过程就是一个上下文切换的过程：

- 由running -> 非running，线程暂停，线程切出，操作系统保存上下文

- 由非running -> running，线程唤醒，唤醒并不代表可以立刻占用处理器。只有被唤醒且占用处理器的时候，操作系统会恢复上下文

### 上下文切换的分类和原因

- 自发性上下文切换

    - Thread.sleep

    - Object.wait

    - Thread.yield

    - Thread.join

    - LockSupport.park()

    - IO操作

    - 等待其他线程持有的锁

- 非自发性上下文切换

    - 时间片用完

    - 优先级更高的线程需要执行

    - java平台中的垃圾回收

### 上下文切换的开销

- 直接开销

    - 操作系统保存和恢复上下文所需的开销

    - 线程调度器的开销

- 间接开销

    - 处理器高速缓存重新加载的开销

    - 可能导致一级高速缓存中的内容被冲刷


## 线程同步

### 生产者-消费者模式

1. 生产者和消费者模式的优点：可以使程序中原本串行的处理得以并发化

2. 生产者和消费者模式中如何在不同线程中传递数据？通过阻塞队列

3. 阻塞队列不仅能够传递数据，还在一定程度上平衡生产者和消费者处理能力。

### 阻塞队列

在java中的阻塞队列BlockingQueue：

- ArrayBlockingQueue：使用数组作为存储空间，put和take操作使用同一个锁（可能操作同一块内存）

- LinkedBlockingQueue：动态分配内存，put和take操作使用不同的锁

- SynchronousQueue：生产者put时阻塞，直到消费者take之后再返回；消费者take时阻塞，直到生产者put后返回

三种阻塞队列的使用场景选择：

- LinkedBlockingQueue：适合在生产者和消费者之间并发程度较大

- ArrayBlockingQueue：适合生产者和消费者之间并发程度较低

- SynchronousQueue：适合生产者和消费者处理能力相差不大


## 第六章：保证线程安全的设计技术

从面向对象设计的角度出发介绍几种保证线程安全的常用技术

### java运行时存储空间

- 堆空间：存储对象实例

- 栈空间：每个线程都有栈空间，线程创建时分配。

    - 调用方法前，会为每一个方法调用创建一个栈帧，存储局部变量和返回值。

    - 线程对局部变量以及只有通过当前线程的局部变量才能访问的对象具有线程安全性。

- 非堆空间：存储常量以及类的元数据。类的元数据包括类的静态变量，类的方法以及方法相关参数

堆空间和非堆空间是线程间可共享的的空间，表现为实例变量和静态变量是线程间可共享的；栈空间是线程的私有空间，表现为线程对局部变量以及只有通过当前线程的局部变量才能访问的对象具有线程安全性。

### 无状态对象

1. 对象是数据和操作的封装，数据包括：

- 实例变量

- 静态变量

- 该对象引用的其他对象的实例变量或者静态变量

对象所包含的数据称为对象的状态，实例变量和静态变量成为状态变量。

2. 如果一个类的同一实例被多个线程共享，但不会使这些线程存在共享状态，则称这个类以及任意实例被称为无状态对象：

- 无状态对象：不包含任意实例变量，不包含任何静态变量或者静态变量都是只读的

- 有状态对象：

    - 状态可变对象

    - 状态不可变对象

无状态对象具有固有的线程安全性，有两层含义：

- 客户端代码在调用该对象的任何方法时都无须加锁

- 无状态对象自身的方法实现也无须加锁

3. 不可变对象：是指一经创建其状态就保持不变的对象。不可变对象需要满足如下条件

- 类本身用final修饰，防止创建子类改变其行为

- 所有字段都用final修饰

- 对象在初始化过程中没有逸出

- 如果字段引用了其他状态可变的对象，则字段必须用private修饰，相关方法返回字段时，进行防御性复制

### 线程持有对象



