<!--
 * @Author: kekexili1230 457738564@qq.com
 * @Date: 2023-12-19 18:18:57
 * @LastEditors: kekexili1230 457738564@qq.com
 * @LastEditTime: 2023-12-20 15:15:10
 * @FilePath: /mynote/docker 和 k8s.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%
-->
# docker笔记

## 容器和虚拟机对比

容器和虚拟机都是用于部署和运行应用程序的技术，但它们在实现和工作原理上有一些关键的区别

- 相同点

  - 隔离性： 容器和虚拟机都提供了隔离性，使得一个应用程序或服务在一个容器或虚拟机中运行时不受其他应用程序的影响。

  - 可移植性： 两者都具有可移植性，可以在不同的环境中运行相同的应用程序，无需担心底层系统的差异

  - 资源分配： 容器和虚拟机都能够分配和管理系统资源，如CPU、内存等。

- 不同点

 - 隔离级别：

   - 容器：容器共享主机操作系统的内核，提供轻量级的隔离。虽然有一定的隔离，但不如虚拟机强。
   
   - 虚拟机：虚拟机在物理硬件上模拟完整的操作系统，提供更强的隔离性，每个虚拟机有自己的内核和用户空间。

- 资源消耗：

  - 容器：容器比虚拟机更轻量级，因为它们共享主机操作系统的内核，资源消耗较低，启动更快。
  
  - 虚拟机：虚拟机需要模拟完整的操作系统，相对较重，启动时间较长，资源消耗较大。

- 启动时间
 
  - 容器： 容器启动时间短，几乎可以瞬间启动。
  
  - 虚拟机： 虚拟机启动时间较长，因为需要启动整个操作系统。

- 部署和扩展

  - 容器： 容器可以快速部署，而且容易扩展和收缩，支持动态调整。
  
  - 虚拟机： 虚拟机部署相对较慢，扩展和收缩可能需要更多的时间和资源。

- 操作系统依赖性

  - 容器： 容器依赖主机操作系统的内核，可能受到主机操作系统的限制。

  - 虚拟机： 虚拟机可以运行不同类型的操作系统，与主机操作系统无关。

## docker引擎

Docker引擎是用于运行和编排容器的基础设施工具，主要由如下主要组件构成：Docker客户端、Docker守护进程、containerd以及runc。

## 常用docker container命令

（1）使用image_name镜像运行一个容器
docker container run -it image_name bash 

（2）登陆一个正在运行的容器docker_name
docker container exex -it docker_name bash

（3）查看所有正在运行的容器
docker container ls

（4）停止容器
docker container stop

（5）删除容器
docket container rm

## 常用docker images命令

- 查看所有的镜像

    docker image ls命令

- 拉取镜像

    docker pull registry.example.com/myrepo/ubuntu:latest

其中：registry.example.com表示仓库地址、myrepo表示仓库名称、ubuntu表示镜像名称。

- 查看容器分层信息

  docker image inspect

- 删除镜像，如果某个镜像层被多个镜像共享，则只有当全部依赖该镜像层的镜像都被删除后，该镜像层才会被删除。

  docker image rm

## 镜像层

1. 所有的docker镜像都起始于一个基础镜像层，当进行修改或者新增加内容时，就会在当前镜像层之上，创建新的镜像层

2. 每一层镜像层都包含一组文件（例如新增文件）或者文件系统的更改（例如创建目录），这些更改是相对前一层的。

3. 共享镜像层：每一个镜像层都有一个唯一的哈希值，根据镜像层的内容生成，用于标识镜像层。在拉取镜像时，如果本地已经存在镜像层，则无需重复拉取。

4. 镜像散列

镜像包含了镜像层列表和一些元数据信息。镜像层实际存储数据，彼此之间相互独立。镜像也由一个加密ID区分，ID由镜像本身内容生成，镜像的唯一标识也是一个加密ID。

## docker容器

虚拟机将硬件资源虚拟化，容器是将操作系统虚拟化

## 容器如何实现隔离？

容器的隔离是通过多个 Linux 内核特性和技术来实现的。以下是一些主要的隔离机制：

- 命名空间（Namespaces）： 命名空间是 Linux 内核提供的一种机制，用于将全局系统资源隔离为独立的实例，每个实例拥有自己的视图。Docker 使用多个命名空间，包括：

  - PID 命名空间： 每个容器都有自己的进程空间，使得它看起来像是在独立的主机上运行。

  - 网络命名空间： 每个容器都有自己的网络空间，拥有独立的网络接口、IP 地址、路由表等。
  
  - 挂载命名空间： 容器可以拥有独立的文件系统视图，不同容器间的文件系统相互隔离。

  - 用户命名空间： 容器内的用户与主机上的用户是分开的，提高了安全性。

- 控制组（Cgroups）： Cgroups 是 Linux 内核提供的一种资源控制机制，允许限制、记录和隔离进程组的资源。Docker 使用 Cgroups 来限制容器的资源使用，如 CPU、内存、磁盘等。

- 容器文件系统： 每个容器都有自己的文件系统，它可以是一个基于镜像的分层文件系统。这种文件系统隔离确保了容器内的文件不会直接影响到主机或其他容器。

- Seccomp： Seccomp 是一个用于限制系统调用的 Linux 内核特性。Docker 支持使用 Seccomp 配置文件来限制容器内部的系统调用，增强容器的安全性。

- Capabilities（权限限制）： Docker 容器运行时会剥夺容器进程的一些特权，只保留必要的权限。这通过 Linux 的 capabilities 机制实现，使容器进程不具备一些危险的权限。



